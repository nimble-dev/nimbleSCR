<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Pierre Dupont" />

<meta name="date" content="2022-08-31" />

<title>Using nimbleSCR to fit ‘point process SCR models’ to wolverine (Gulo gulo) non-invasive genetic sampling data</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Using nimbleSCR to fit ‘point process SCR models’ to wolverine (Gulo gulo) non-invasive genetic sampling data</h1>
<h4 class="author">Pierre Dupont</h4>
<h4 class="date">2022-08-31</h4>



<p>This vignette demonstrates the different wolverine SCR models presented in “A flexible and efficient Bayesian implementation of point process models for spatial capture-recapture data” (Zhang <em>et al</em>, <em>submitted</em>) using NIMBLE <span class="citation">(de Valpine et al. 2017; NIMBLE Development Team 2020)</span> and the nimbleSCR package <span class="citation">(Bischof et al. 2020)</span>.</p>
<div id="load-libraries" class="section level3">
<h3>Load Libraries</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(nimble)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">library</span>(nimbleSCR)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">library</span>(basicMCMCplots)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">library</span>(coda)</a></code></pre></div>
</div>
<div id="define-nimblescr-models" class="section level3">
<h3>Define ‘nimbleSCR’ Models</h3>
<p>Here, we define the first <code>nimble</code> model. It uses i) the Bernoulli point process for modelling the distribution of individual wolverine activity centers, ii) a Poisson point process for modelling individual detections, and iii) a semi-complete data-likelihood approach <span class="citation">(King et al. 2016)</span> to estimate population size.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">modelCode1 &lt;-<span class="st"> </span><span class="kw">nimbleCode</span>({  </a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="co">##------ SPATIAL PROCESS </span></a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="co">## Intercept and slope for the log-linear model for habitat selection intensity</span></a>
<a class="sourceLine" id="cb2-4" title="4">  habCoeffInt <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb2-5" title="5">  habCoeffSlope <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="co">## Habitat intensity for each habitat window</span></a>
<a class="sourceLine" id="cb2-7" title="7">  habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows] &lt;-<span class="st"> </span><span class="kw">exp</span>(habCoeffInt <span class="op">+</span><span class="st"> </span>habCoeffSlope <span class="op">*</span><span class="st"> </span>habCovs[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb2-8" title="8">  sumHabIntensity &lt;-<span class="st"> </span><span class="kw">sum</span>(habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb2-9" title="9">  logHabIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows] &lt;-<span class="st"> </span><span class="kw">log</span>(habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb2-10" title="10">  logSumHabIntensity &lt;-<span class="st"> </span><span class="kw">log</span>(sumHabIntensity)</a>
<a class="sourceLine" id="cb2-11" title="11">  <span class="co">## Activity centres of the observed individuals: a Bernoulli point process</span></a>
<a class="sourceLine" id="cb2-12" title="12">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numIdDetected){</a>
<a class="sourceLine" id="cb2-13" title="13">    sxy[i,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>] <span class="op">~</span><span class="st"> </span><span class="kw">dbernppAC</span>(</a>
<a class="sourceLine" id="cb2-14" title="14">      <span class="dt">lowerCoords =</span> habLoCoords[<span class="dv">1</span><span class="op">:</span>numHabWindows, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb2-15" title="15">      <span class="dt">upperCoords =</span> habUpCoords[<span class="dv">1</span><span class="op">:</span>numHabWindows, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb2-16" title="16">      <span class="dt">logIntensities =</span> logHabIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows],</a>
<a class="sourceLine" id="cb2-17" title="17">      <span class="dt">logSumIntensity =</span> logSumHabIntensity,</a>
<a class="sourceLine" id="cb2-18" title="18">      <span class="dt">habitatGrid =</span> habitatGrid[<span class="dv">1</span><span class="op">:</span>y.max,<span class="dv">1</span><span class="op">:</span>x.max],</a>
<a class="sourceLine" id="cb2-19" title="19">      <span class="dt">numGridRows =</span> y.max,</a>
<a class="sourceLine" id="cb2-20" title="20">      <span class="dt">numGridCols =</span> x.max)</a>
<a class="sourceLine" id="cb2-21" title="21">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb2-22" title="22">  </a>
<a class="sourceLine" id="cb2-23" title="23">  <span class="co">##----- DEMOGRAPHIC PROCESS</span></a>
<a class="sourceLine" id="cb2-24" title="24">  <span class="co">## Number of individuals in the population</span></a>
<a class="sourceLine" id="cb2-25" title="25">  N <span class="op">~</span><span class="st"> </span><span class="kw">dpois</span>(sumHabIntensity)</a>
<a class="sourceLine" id="cb2-26" title="26">  <span class="co">## Number of detected individuals</span></a>
<a class="sourceLine" id="cb2-27" title="27">  nDetectedIndiv <span class="op">~</span><span class="st"> </span><span class="kw">dbin</span>(probDetection, N)</a>
<a class="sourceLine" id="cb2-28" title="28"></a>
<a class="sourceLine" id="cb2-29" title="29">  <span class="co">##----- DETECTION PROCESS </span></a>
<a class="sourceLine" id="cb2-30" title="30">  <span class="co">## Scale for the multivariate normal detection function</span></a>
<a class="sourceLine" id="cb2-31" title="31">  sigma <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb2-32" title="32">  <span class="co">## Intercept and slope parameters for the log-linear model for detection intensity</span></a>
<a class="sourceLine" id="cb2-33" title="33">  <span class="cf">for</span>(c <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numCounties){</a>
<a class="sourceLine" id="cb2-34" title="34">    detCoeffInt[c] <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb2-35" title="35">  }<span class="co">#c</span></a>
<a class="sourceLine" id="cb2-36" title="36">  <span class="cf">for</span>(cc <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numDetCovs){</a>
<a class="sourceLine" id="cb2-37" title="37">    detCoeffSlope[cc] <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb2-38" title="38">  }<span class="co">#cc</span></a>
<a class="sourceLine" id="cb2-39" title="39">  <span class="co">## Baseline detection intensity for each detection window</span></a>
<a class="sourceLine" id="cb2-40" title="40">  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numDetWindows){</a>
<a class="sourceLine" id="cb2-41" title="41">    detIntensity[j] &lt;-<span class="st"> </span><span class="kw">exp</span>( detCoeffInt[detCounties[j]] <span class="op">+</span></a>
<a class="sourceLine" id="cb2-42" title="42"><span class="st">                              </span>detCoeffSlope[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">1</span>] <span class="op">+</span></a>
<a class="sourceLine" id="cb2-43" title="43"><span class="st">                              </span>detCoeffSlope[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">2</span>] <span class="op">+</span></a>
<a class="sourceLine" id="cb2-44" title="44"><span class="st">                              </span>detCoeffSlope[<span class="dv">3</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb2-45" title="45">  }<span class="co">#j</span></a>
<a class="sourceLine" id="cb2-46" title="46">  <span class="co">## Detections of the observed individuals conditional on their activity centers</span></a>
<a class="sourceLine" id="cb2-47" title="47">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numIdDetected) {</a>
<a class="sourceLine" id="cb2-48" title="48">    y[i,<span class="dv">1</span><span class="op">:</span>(maxDetections<span class="op">+</span><span class="dv">1</span>),<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>] <span class="op">~</span><span class="st"> </span><span class="kw">dpoisppDetection_normal</span>(</a>
<a class="sourceLine" id="cb2-49" title="49">      <span class="dt">lowerCoords =</span> detLoCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb2-50" title="50">      <span class="dt">upperCoords =</span> detUpCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb2-51" title="51">      <span class="dt">s =</span> sxy[i,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb2-52" title="52">      <span class="dt">sd =</span> sigma,</a>
<a class="sourceLine" id="cb2-53" title="53">      <span class="dt">baseIntensities =</span> detIntensity[<span class="dv">1</span><span class="op">:</span>numDetWindows],</a>
<a class="sourceLine" id="cb2-54" title="54">      <span class="dt">numMaxPoints =</span> maxDetections,</a>
<a class="sourceLine" id="cb2-55" title="55">      <span class="dt">numWindows =</span> numDetWindows,</a>
<a class="sourceLine" id="cb2-56" title="56">      <span class="dt">indicator =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-57" title="57">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb2-58" title="58"></a>
<a class="sourceLine" id="cb2-59" title="59">  <span class="co">## The probability that an individual in the population is detected at least once</span></a>
<a class="sourceLine" id="cb2-60" title="60">  <span class="co">## i.e. one minus the void probability over all detection windows</span></a>
<a class="sourceLine" id="cb2-61" title="61">  probDetection &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">marginalVoidProbNumIntegration</span>(</a>
<a class="sourceLine" id="cb2-62" title="62">    <span class="dt">quadNodes =</span> quadNodes[<span class="dv">1</span><span class="op">:</span>maxNumNodes,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>,<span class="dv">1</span><span class="op">:</span>numHabWindows],</a>
<a class="sourceLine" id="cb2-63" title="63">    <span class="dt">quadWeights =</span> quadWeights[<span class="dv">1</span><span class="op">:</span>numHabWindows],</a>
<a class="sourceLine" id="cb2-64" title="64">    <span class="dt">numNodes =</span> numNodes[<span class="dv">1</span><span class="op">:</span>numHabWindows],</a>
<a class="sourceLine" id="cb2-65" title="65">    <span class="dt">lowerCoords =</span> detLoCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb2-66" title="66">    <span class="dt">upperCoords =</span> detUpCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb2-67" title="67">    <span class="dt">sd =</span> sigma,</a>
<a class="sourceLine" id="cb2-68" title="68">    <span class="dt">baseIntensities =</span> detIntensity[<span class="dv">1</span><span class="op">:</span>numDetWindows],</a>
<a class="sourceLine" id="cb2-69" title="69">    <span class="dt">habIntensities =</span> habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows],</a>
<a class="sourceLine" id="cb2-70" title="70">    <span class="dt">sumHabIntensity =</span> sumHabIntensity,</a>
<a class="sourceLine" id="cb2-71" title="71">    <span class="dt">numObsWindows =</span> numDetWindows,</a>
<a class="sourceLine" id="cb2-72" title="72">    <span class="dt">numHabWindows =</span> numHabWindows</a>
<a class="sourceLine" id="cb2-73" title="73">  )</a>
<a class="sourceLine" id="cb2-74" title="74">  logDetProb &lt;-<span class="st"> </span><span class="kw">log</span>(probDetection)</a>
<a class="sourceLine" id="cb2-75" title="75">  normData <span class="op">~</span><span class="st"> </span><span class="kw">dnormalizer</span>(<span class="dt">logNormConstant =</span> <span class="op">-</span>numIdDetected<span class="op">*</span>logDetProb)</a>
<a class="sourceLine" id="cb2-76" title="76"></a>
<a class="sourceLine" id="cb2-77" title="77">})</a></code></pre></div>
<p>Next, we can define a second <code>nimble</code> model based on the “usual” formulation of Bayesian SCR models. In this model, individual activity center locations are modeled using a two-step process in which i) a categorical distribution is used to sample the habitat window the activity center is located in, and ii) the center of the selected habitat window is used as the location of the activity center inside the selected habitat window. The probability vector of the categorical process follows the intensity of the density point process of the first formulation. Individual detections are not modeled continuously in space, instead they are aggregated at discrete detector locations and the number of detections at each detector is modeled using a Poisson distribution. Finally, we use the data augmentation approach <span class="citation">(Royle and Dorazio 2012)</span> to derive population size instead of the semi-complete data-likelihood approach.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">modelCode2 &lt;-<span class="st"> </span><span class="kw">nimbleCode</span>({</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="co">##------ SPATIAL PROCESS</span></a>
<a class="sourceLine" id="cb3-3" title="3">  habCoeffSlope <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="co">## Habitat intensity for each habitat window</span></a>
<a class="sourceLine" id="cb3-5" title="5">  habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows] &lt;-<span class="st"> </span><span class="kw">exp</span>(habCoeffSlope <span class="op">*</span><span class="st"> </span>habCovs[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){</a>
<a class="sourceLine" id="cb3-7" title="7">    sID[i] <span class="op">~</span><span class="st"> </span><span class="kw">dcat</span>(habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb3-8" title="8">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="co">##----- DEMOGRAPHIC PROCESS</span></a>
<a class="sourceLine" id="cb3-11" title="11">  psi <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-12" title="12">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){</a>
<a class="sourceLine" id="cb3-13" title="13">    z[i] <span class="op">~</span><span class="st"> </span><span class="kw">dbern</span>(psi)</a>
<a class="sourceLine" id="cb3-14" title="14">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb3-15" title="15">  <span class="co">## Number of individuals in the population</span></a>
<a class="sourceLine" id="cb3-16" title="16">  N &lt;-<span class="st"> </span><span class="kw">sum</span>(z[<span class="dv">1</span><span class="op">:</span>M])</a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18">  <span class="co">##----- DETECTION PROCESS</span></a>
<a class="sourceLine" id="cb3-19" title="19">  <span class="co">## Scale for the multivariate normal detection function</span></a>
<a class="sourceLine" id="cb3-20" title="20">  sigma <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb3-21" title="21">  <span class="co">## Intercept and slope parameters for the log-linear model for detection intensity</span></a>
<a class="sourceLine" id="cb3-22" title="22">  <span class="cf">for</span>(c <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numCounties){</a>
<a class="sourceLine" id="cb3-23" title="23">    detCoeffInt[c] <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb3-24" title="24">  }<span class="co">#c</span></a>
<a class="sourceLine" id="cb3-25" title="25">  <span class="cf">for</span>(cc <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numDetCovs){</a>
<a class="sourceLine" id="cb3-26" title="26">    detCoeffSlope[cc] <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb3-27" title="27">  }<span class="co">#cc</span></a>
<a class="sourceLine" id="cb3-28" title="28">  <span class="co">## Baseline detection intensity for each detection window</span></a>
<a class="sourceLine" id="cb3-29" title="29">  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numDetWindows){</a>
<a class="sourceLine" id="cb3-30" title="30">    lambdaTraps[j] &lt;-<span class="st"> </span><span class="kw">exp</span>( detCoeffInt[detCounties[j]] <span class="op">+</span></a>
<a class="sourceLine" id="cb3-31" title="31"><span class="st">                             </span>detCoeffSlope[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">1</span>] <span class="op">+</span></a>
<a class="sourceLine" id="cb3-32" title="32"><span class="st">                             </span>detCoeffSlope[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">2</span>] <span class="op">+</span></a>
<a class="sourceLine" id="cb3-33" title="33"><span class="st">                             </span>detCoeffSlope[<span class="dv">3</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb3-34" title="34">  }<span class="co">#j</span></a>
<a class="sourceLine" id="cb3-35" title="35"></a>
<a class="sourceLine" id="cb3-36" title="36">  <span class="co">## Detections of the observed individuals conditional on their activity centers</span></a>
<a class="sourceLine" id="cb3-37" title="37">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M) {</a>
<a class="sourceLine" id="cb3-38" title="38">    y[i,<span class="dv">1</span><span class="op">:</span>lengthYCombined] <span class="op">~</span><span class="st"> </span><span class="kw">dpoisLocal_normal</span>(</a>
<a class="sourceLine" id="cb3-39" title="39">      <span class="dt">lambdaTraps =</span> lambdaTraps[<span class="dv">1</span><span class="op">:</span>numDetWindows],</a>
<a class="sourceLine" id="cb3-40" title="40">      <span class="dt">trapCoords =</span> detCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb3-41" title="41">      <span class="dt">s =</span> habCoords[sID[i],<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb3-42" title="42">      <span class="dt">sigma =</span> sigma,</a>
<a class="sourceLine" id="cb3-43" title="43">      <span class="dt">localTrapsIndices =</span> localTrapsIndices[<span class="dv">1</span><span class="op">:</span>numHabWindows,<span class="dv">1</span><span class="op">:</span>numDetWindows],</a>
<a class="sourceLine" id="cb3-44" title="44">      <span class="dt">localTrapsNum =</span> localTrapsNum[<span class="dv">1</span><span class="op">:</span>numHabWindows],</a>
<a class="sourceLine" id="cb3-45" title="45">      <span class="dt">habitatGrid =</span> habitatGrid[<span class="dv">1</span><span class="op">:</span>y.max,<span class="dv">1</span><span class="op">:</span>x.max],</a>
<a class="sourceLine" id="cb3-46" title="46">      <span class="dt">lengthYCombined =</span> lengthYCombined,</a>
<a class="sourceLine" id="cb3-47" title="47">      <span class="dt">indicator =</span> z[i])</a>
<a class="sourceLine" id="cb3-48" title="48">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb3-49" title="49">})</a></code></pre></div>
<p>For comparison purposes, we define a third <code>nimble</code> model, which is a hybrid formulation of the two previous ones. It uses i) the Bernoulli point process for modelling the distribution of wolverine activity centers and ii) a Poisson point process to model individual detections in continuous space but uses iii) data augmentation instead of the semi-complete data-likelihood approach to estimate population size. This formulation is expected to be both a better representation of the detection process (thus more accurate than model 2) and more efficient than model 1 because of the complexity of the semi-complete data likelihood calculation.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">modelCode3 &lt;-<span class="st"> </span><span class="kw">nimbleCode</span>({</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="co">##------ SPATIAL PROCESS</span></a>
<a class="sourceLine" id="cb4-3" title="3">  habCoeffSlope <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="co">## Habitat intensity for each habitat window</span></a>
<a class="sourceLine" id="cb4-5" title="5">  habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows] &lt;-<span class="st"> </span><span class="kw">exp</span>(habCoeffSlope <span class="op">*</span><span class="st"> </span>habCovs[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb4-6" title="6">  sumHabIntensity &lt;-<span class="st"> </span><span class="kw">sum</span>(habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb4-7" title="7">  logHabIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows] &lt;-<span class="st"> </span><span class="kw">log</span>(habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb4-8" title="8">  logSumHabIntensity &lt;-<span class="st"> </span><span class="kw">log</span>(sumHabIntensity)</a>
<a class="sourceLine" id="cb4-9" title="9">  <span class="co">## Activity centres of the observed individuals: a bernoulli point process</span></a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){</a>
<a class="sourceLine" id="cb4-11" title="11">    sxy[i,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>] <span class="op">~</span><span class="st"> </span><span class="kw">dbernppAC</span>(</a>
<a class="sourceLine" id="cb4-12" title="12">      <span class="dt">lowerCoords =</span> habLoCoords[<span class="dv">1</span><span class="op">:</span>numHabWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb4-13" title="13">      <span class="dt">upperCoords =</span> habUpCoords[<span class="dv">1</span><span class="op">:</span>numHabWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb4-14" title="14">      <span class="dt">logIntensities =</span> logHabIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows],</a>
<a class="sourceLine" id="cb4-15" title="15">      <span class="dt">logSumIntensity =</span> logSumHabIntensity,</a>
<a class="sourceLine" id="cb4-16" title="16">      <span class="dt">habitatGrid =</span> habitatGrid[<span class="dv">1</span><span class="op">:</span>y.max,<span class="dv">1</span><span class="op">:</span>x.max],</a>
<a class="sourceLine" id="cb4-17" title="17">      <span class="dt">numGridRows =</span> y.max,</a>
<a class="sourceLine" id="cb4-18" title="18">      <span class="dt">numGridCols =</span> x.max)</a>
<a class="sourceLine" id="cb4-19" title="19">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb4-20" title="20"></a>
<a class="sourceLine" id="cb4-21" title="21">  <span class="co">##----- DEMOGRAPHIC PROCESS</span></a>
<a class="sourceLine" id="cb4-22" title="22">  psi <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-23" title="23">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){</a>
<a class="sourceLine" id="cb4-24" title="24">    z[i] <span class="op">~</span><span class="st"> </span><span class="kw">dbern</span>(psi)</a>
<a class="sourceLine" id="cb4-25" title="25">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb4-26" title="26">  <span class="co">## Number of individuals in the population</span></a>
<a class="sourceLine" id="cb4-27" title="27">  N &lt;-<span class="st"> </span><span class="kw">sum</span>(z[<span class="dv">1</span><span class="op">:</span>M])</a>
<a class="sourceLine" id="cb4-28" title="28"></a>
<a class="sourceLine" id="cb4-29" title="29">  <span class="co">##----- DETECTION PROCESS</span></a>
<a class="sourceLine" id="cb4-30" title="30">  <span class="co">## Scale for the half-normal detection function</span></a>
<a class="sourceLine" id="cb4-31" title="31">  sigma <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb4-32" title="32">  <span class="co">## Intercept and slope parameters for the log-linear model for detection intensity</span></a>
<a class="sourceLine" id="cb4-33" title="33">  <span class="cf">for</span>(c <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numCounties){</a>
<a class="sourceLine" id="cb4-34" title="34">    detCoeffInt[c] <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb4-35" title="35">  }<span class="co">#c</span></a>
<a class="sourceLine" id="cb4-36" title="36">  <span class="cf">for</span>(cc <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numDetCovs){</a>
<a class="sourceLine" id="cb4-37" title="37">    detCoeffSlope[cc] <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb4-38" title="38">  }<span class="co">#cc</span></a>
<a class="sourceLine" id="cb4-39" title="39">  <span class="co">## Baseline detection intensity for each detection window</span></a>
<a class="sourceLine" id="cb4-40" title="40">  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numDetWindows){</a>
<a class="sourceLine" id="cb4-41" title="41">    detIntensity[j] &lt;-<span class="st"> </span><span class="kw">exp</span>( detCoeffInt[detCounties[j]] <span class="op">+</span></a>
<a class="sourceLine" id="cb4-42" title="42"><span class="st">                              </span>detCoeffSlope[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">1</span>] <span class="op">+</span></a>
<a class="sourceLine" id="cb4-43" title="43"><span class="st">                              </span>detCoeffSlope[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">2</span>] <span class="op">+</span></a>
<a class="sourceLine" id="cb4-44" title="44"><span class="st">                              </span>detCoeffSlope[<span class="dv">3</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb4-45" title="45">  }<span class="co">#j</span></a>
<a class="sourceLine" id="cb4-46" title="46"></a>
<a class="sourceLine" id="cb4-47" title="47">  <span class="co">## Detections of the observed individuals conditional on their activity centers</span></a>
<a class="sourceLine" id="cb4-48" title="48">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){</a>
<a class="sourceLine" id="cb4-49" title="49">    y[i,<span class="dv">1</span><span class="op">:</span>(maxDetections<span class="op">+</span><span class="dv">1</span>),<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>] <span class="op">~</span><span class="st"> </span><span class="kw">dpoisppDetection_normal</span>(</a>
<a class="sourceLine" id="cb4-50" title="50">      <span class="dt">lowerCoords =</span> detLoCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb4-51" title="51">      <span class="dt">upperCoords =</span> detUpCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb4-52" title="52">      <span class="dt">s =</span> sxy[i,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb4-53" title="53">      <span class="dt">sd =</span> sigma,</a>
<a class="sourceLine" id="cb4-54" title="54">      <span class="dt">baseIntensities =</span> detIntensity[<span class="dv">1</span><span class="op">:</span>numDetWindows],</a>
<a class="sourceLine" id="cb4-55" title="55">      <span class="dt">numMaxPoints =</span> maxDetections,</a>
<a class="sourceLine" id="cb4-56" title="56">      <span class="dt">numWindows =</span> numDetWindows,</a>
<a class="sourceLine" id="cb4-57" title="57">      <span class="dt">indicator =</span> z[i])</a>
<a class="sourceLine" id="cb4-58" title="58">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb4-59" title="59">})</a></code></pre></div>
<p>We can also define a fourth <code>nimble</code> model, which uses the categorical distribution to model the distribution of wolverine activity centers, a Poisson point process to model individual detections in continuous space and data augmentation to estimate population size. This formulation is expected to be slower than version 3 because of the categorical process.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1">modelCode4 &lt;-<span class="st"> </span><span class="kw">nimbleCode</span>({</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="co">##------ SPATIAL PROCESS</span></a>
<a class="sourceLine" id="cb5-3" title="3">  habCoeffSlope <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="co">## Habitat intensity for each habitat window</span></a>
<a class="sourceLine" id="cb5-5" title="5">  habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows] &lt;-<span class="st"> </span><span class="kw">exp</span>(habCoeffSlope <span class="op">*</span><span class="st"> </span>habCovs[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){</a>
<a class="sourceLine" id="cb5-7" title="7">    sID[i] <span class="op">~</span><span class="st"> </span><span class="kw">dcat</span>(habIntensity[<span class="dv">1</span><span class="op">:</span>numHabWindows])</a>
<a class="sourceLine" id="cb5-8" title="8">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="co">##----- DEMOGRAPHIC PROCESS</span></a>
<a class="sourceLine" id="cb5-11" title="11">  psi <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-12" title="12">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){</a>
<a class="sourceLine" id="cb5-13" title="13">    z[i] <span class="op">~</span><span class="st"> </span><span class="kw">dbern</span>(psi)</a>
<a class="sourceLine" id="cb5-14" title="14">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb5-15" title="15">  <span class="co">## Number of individuals in the population</span></a>
<a class="sourceLine" id="cb5-16" title="16">  N &lt;-<span class="st"> </span><span class="kw">sum</span>(z[<span class="dv">1</span><span class="op">:</span>M])</a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18">  <span class="co">##----- DETECTION PROCESS</span></a>
<a class="sourceLine" id="cb5-19" title="19">  <span class="co">## Scale for the half-normal detection function</span></a>
<a class="sourceLine" id="cb5-20" title="20">  sigma <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-21" title="21">  <span class="co">## Intercept and slope parameters for the log-linear model for detection intensity</span></a>
<a class="sourceLine" id="cb5-22" title="22">  <span class="cf">for</span>(c <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numCounties){</a>
<a class="sourceLine" id="cb5-23" title="23">    detCoeffInt[c] <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-24" title="24">  }<span class="co">#c</span></a>
<a class="sourceLine" id="cb5-25" title="25">  <span class="cf">for</span>(cc <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numDetCovs){</a>
<a class="sourceLine" id="cb5-26" title="26">    detCoeffSlope[cc] <span class="op">~</span><span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-27" title="27">  }<span class="co">#cc</span></a>
<a class="sourceLine" id="cb5-28" title="28">  <span class="co">## Baseline detection intensity for each detection window</span></a>
<a class="sourceLine" id="cb5-29" title="29">  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numDetWindows){</a>
<a class="sourceLine" id="cb5-30" title="30">    detIntensity[j] &lt;-<span class="st"> </span><span class="kw">exp</span>( detCoeffInt[detCounties[j]] <span class="op">+</span></a>
<a class="sourceLine" id="cb5-31" title="31"><span class="st">                              </span>detCoeffSlope[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">1</span>] <span class="op">+</span></a>
<a class="sourceLine" id="cb5-32" title="32"><span class="st">                              </span>detCoeffSlope[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">2</span>] <span class="op">+</span></a>
<a class="sourceLine" id="cb5-33" title="33"><span class="st">                              </span>detCoeffSlope[<span class="dv">3</span>] <span class="op">*</span><span class="st"> </span>detCovs[j,<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb5-34" title="34">  }<span class="co">#j</span></a>
<a class="sourceLine" id="cb5-35" title="35"></a>
<a class="sourceLine" id="cb5-36" title="36">  <span class="co">## Detections of the observed individuals conditional on their activity centers</span></a>
<a class="sourceLine" id="cb5-37" title="37">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){</a>
<a class="sourceLine" id="cb5-38" title="38">    y[i,<span class="dv">1</span><span class="op">:</span>(maxDetections<span class="op">+</span><span class="dv">1</span>),<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>] <span class="op">~</span><span class="st"> </span><span class="kw">dpoisppDetection_normal</span>(</a>
<a class="sourceLine" id="cb5-39" title="39">      <span class="dt">lowerCoords =</span> detLoCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb5-40" title="40">      <span class="dt">upperCoords =</span> detUpCoords[<span class="dv">1</span><span class="op">:</span>numDetWindows,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb5-41" title="41">      <span class="dt">s =</span> habCoords[sID[i],<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb5-42" title="42">      <span class="dt">sd =</span> sigma,</a>
<a class="sourceLine" id="cb5-43" title="43">      <span class="dt">baseIntensities =</span> detIntensity[<span class="dv">1</span><span class="op">:</span>numDetWindows],</a>
<a class="sourceLine" id="cb5-44" title="44">      <span class="dt">numMaxPoints =</span> maxDetections,</a>
<a class="sourceLine" id="cb5-45" title="45">      <span class="dt">numWindows =</span> numDetWindows,</a>
<a class="sourceLine" id="cb5-46" title="46">      <span class="dt">indicator =</span> z[i])</a>
<a class="sourceLine" id="cb5-47" title="47">  }<span class="co">#i</span></a>
<a class="sourceLine" id="cb5-48" title="48">})</a></code></pre></div>
</div>
<div id="load-wolverine-data" class="section level3">
<h3>Load Wolverine Data</h3>
<p>We load the wolverine example data available directly via <code>nimbleSCR</code></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">load</span>(<span class="st">&quot;WolverinePointProcess_Data.RData&quot;</span>)</a></code></pre></div>
</div>
<div id="create-nimble-model" class="section level2">
<h2>Create NIMBLE Model</h2>
<p>Now, we can create the <code>nimble</code> model objects, using the model structures defined above, as well as the constants, data, and initial values.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1">Rmodel1 &lt;-<span class="st"> </span><span class="kw">nimbleModel</span>(modelCode1, constants1, data1, inits1)</a>
<a class="sourceLine" id="cb7-2" title="2">Rmodel2 &lt;-<span class="st"> </span><span class="kw">nimbleModel</span>(modelCode2, constants2, data2, inits2)</a>
<a class="sourceLine" id="cb7-3" title="3">Rmodel3 &lt;-<span class="st"> </span><span class="kw">nimbleModel</span>(modelCode3, constants3, data3, inits3)</a>
<a class="sourceLine" id="cb7-4" title="4">Rmodel4 &lt;-<span class="st"> </span><span class="kw">nimbleModel</span>(modelCode4, constants4, data4, inits4)</a></code></pre></div>
<div id="configure-and-build-mcmc" class="section level4">
<h4>Configure and Build MCMC</h4>
<p>We configure an MCMC algorithm for each <code>Rmodel</code> model object and we assign MCMC monitors to the different parameters we want to track (e.g. <span class="math inline">\(N\)</span>, <span class="math inline">\(\sigma\)</span>, …)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1">conf1 &lt;-<span class="st"> </span><span class="kw">configureMCMC</span>( Rmodel1,</a>
<a class="sourceLine" id="cb8-2" title="2">                       <span class="dt">monitors =</span> params1,</a>
<a class="sourceLine" id="cb8-3" title="3">                       <span class="dt">print =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb8-4" title="4">conf2 &lt;-<span class="st"> </span><span class="kw">configureMCMC</span>( Rmodel2,</a>
<a class="sourceLine" id="cb8-5" title="5">                       <span class="dt">monitors =</span> params2,</a>
<a class="sourceLine" id="cb8-6" title="6">                       <span class="dt">print =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb8-7" title="7">conf3 &lt;-<span class="st"> </span><span class="kw">configureMCMC</span>( Rmodel3,</a>
<a class="sourceLine" id="cb8-8" title="8">                       <span class="dt">monitors =</span> params3,</a>
<a class="sourceLine" id="cb8-9" title="9">                       <span class="dt">print =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb8-10" title="10">conf4 &lt;-<span class="st"> </span><span class="kw">configureMCMC</span>( Rmodel4,</a>
<a class="sourceLine" id="cb8-11" title="11">                       <span class="dt">monitors =</span> params4,</a>
<a class="sourceLine" id="cb8-12" title="12">                       <span class="dt">print =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb8-13" title="13">Rmcmc1 &lt;-<span class="st"> </span><span class="kw">buildMCMC</span>(conf1)</a>
<a class="sourceLine" id="cb8-14" title="14">Rmcmc2 &lt;-<span class="st"> </span><span class="kw">buildMCMC</span>(conf2)</a>
<a class="sourceLine" id="cb8-15" title="15">Rmcmc3 &lt;-<span class="st"> </span><span class="kw">buildMCMC</span>(conf3)</a>
<a class="sourceLine" id="cb8-16" title="16">Rmcmc4 &lt;-<span class="st"> </span><span class="kw">buildMCMC</span>(conf4)</a></code></pre></div>
</div>
<div id="compile-and-run-mcmc" class="section level4">
<h4>Compile and Run MCMC</h4>
<p>Finally, we compile the models and MCMC objects and execute the compiled MCMC runs for 4 chains of 11000 iterations each.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1">Cmodel1 &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(Rmodel1)</a>
<a class="sourceLine" id="cb9-2" title="2">Cmcmc1 &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(Rmcmc1, <span class="dt">project =</span> Rmodel1)</a>
<a class="sourceLine" id="cb9-3" title="3">MCMC_runtime1 &lt;-<span class="st"> </span><span class="kw">system.time</span>(</a>
<a class="sourceLine" id="cb9-4" title="4">  MCMC_samples1 &lt;-<span class="st"> </span><span class="kw">runMCMC</span>(Cmcmc1,</a>
<a class="sourceLine" id="cb9-5" title="5">                           <span class="dt">niter =</span> <span class="dv">11000</span>,</a>
<a class="sourceLine" id="cb9-6" title="6">                           <span class="dt">nburnin =</span> <span class="dv">1000</span>,</a>
<a class="sourceLine" id="cb9-7" title="7">                           <span class="dt">nchains =</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9">Cmodel2 &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(Rmodel2)</a>
<a class="sourceLine" id="cb9-10" title="10">Cmcmc2 &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(Rmcmc2, <span class="dt">project =</span> Rmodel2)</a>
<a class="sourceLine" id="cb9-11" title="11">MCMC_runtime2 &lt;-<span class="st"> </span><span class="kw">system.time</span>(</a>
<a class="sourceLine" id="cb9-12" title="12">  MCMC_samples2 &lt;-<span class="st"> </span><span class="kw">runMCMC</span>(Cmcmc2,  </a>
<a class="sourceLine" id="cb9-13" title="13">                           <span class="dt">niter =</span> <span class="dv">11000</span>,</a>
<a class="sourceLine" id="cb9-14" title="14">                           <span class="dt">nburnin =</span> <span class="dv">1000</span>,</a>
<a class="sourceLine" id="cb9-15" title="15">                           <span class="dt">nchains =</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb9-16" title="16"></a>
<a class="sourceLine" id="cb9-17" title="17">Cmodel3 &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(Rmodel3)</a>
<a class="sourceLine" id="cb9-18" title="18">Cmcmc3 &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(Rmcmc3, <span class="dt">project =</span> Rmodel3)</a>
<a class="sourceLine" id="cb9-19" title="19">MCMC_runtime3 &lt;-<span class="st"> </span><span class="kw">system.time</span>(</a>
<a class="sourceLine" id="cb9-20" title="20">  MCMC_samples3 &lt;-<span class="st"> </span><span class="kw">runMCMC</span>(Cmcmc3,  </a>
<a class="sourceLine" id="cb9-21" title="21">                           <span class="dt">niter =</span> <span class="dv">11000</span>,</a>
<a class="sourceLine" id="cb9-22" title="22">                           <span class="dt">nburnin =</span> <span class="dv">1000</span>,</a>
<a class="sourceLine" id="cb9-23" title="23">                           <span class="dt">nchains =</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb9-24" title="24"></a>
<a class="sourceLine" id="cb9-25" title="25">Cmodel4 &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(Rmodel4)</a>
<a class="sourceLine" id="cb9-26" title="26">Cmcmc4 &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(Rmcmc4, <span class="dt">project =</span> Rmodel4)</a>
<a class="sourceLine" id="cb9-27" title="27">MCMC_runtime4 &lt;-<span class="st"> </span><span class="kw">system.time</span>(</a>
<a class="sourceLine" id="cb9-28" title="28">  MCMC_samples4 &lt;-<span class="st"> </span><span class="kw">runMCMC</span>(Cmcmc4,  </a>
<a class="sourceLine" id="cb9-29" title="29">                           <span class="dt">niter =</span> <span class="dv">11000</span>,</a>
<a class="sourceLine" id="cb9-30" title="30">                           <span class="dt">nburnin =</span> <span class="dv">1000</span>,</a>
<a class="sourceLine" id="cb9-31" title="31">                           <span class="dt">nchains =</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb9-32" title="32"></a>
<a class="sourceLine" id="cb9-33" title="33">MCMC_samples1_summary &lt;-<span class="st"> </span><span class="kw">samplesSummary</span>(<span class="kw">do.call</span>(rbind,MCMC_samples1))</a>
<a class="sourceLine" id="cb9-34" title="34">MCMC_samples2_summary &lt;-<span class="st"> </span><span class="kw">samplesSummary</span>(<span class="kw">do.call</span>(rbind,MCMC_samples2))</a>
<a class="sourceLine" id="cb9-35" title="35">MCMC_samples3_summary &lt;-<span class="st"> </span><span class="kw">samplesSummary</span>(<span class="kw">do.call</span>(rbind,MCMC_samples3))</a>
<a class="sourceLine" id="cb9-36" title="36">MCMC_samples4_summary &lt;-<span class="st"> </span><span class="kw">samplesSummary</span>(<span class="kw">do.call</span>(rbind,MCMC_samples4))</a>
<a class="sourceLine" id="cb9-37" title="37"></a>
<a class="sourceLine" id="cb9-38" title="38">MCMC_samples1_ess &lt;-<span class="st"> </span><span class="kw">effectiveSize</span>(MCMC_samples1)</a>
<a class="sourceLine" id="cb9-39" title="39">MCMC_samples2_ess &lt;-<span class="st"> </span><span class="kw">effectiveSize</span>(MCMC_samples2)</a>
<a class="sourceLine" id="cb9-40" title="40">MCMC_samples3_ess &lt;-<span class="st"> </span><span class="kw">effectiveSize</span>(MCMC_samples3)</a>
<a class="sourceLine" id="cb9-41" title="41">MCMC_samples4_ess &lt;-<span class="st"> </span><span class="kw">effectiveSize</span>(MCMC_samples4)</a></code></pre></div>
</div>
</div>
<div id="results" class="section level2">
<h2>Results</h2>
<p>We can then look at the summary of posterior distributions for the different models:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">round</span>(MCMC_samples1_summary, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##                    Mean Median St.Dev. 95%CI_low 95%CI_upp
## N                137.33 137.00   12.27    115.00    163.00
## detCoeffInt[1]     3.45   3.47    0.84      1.75      5.01
## detCoeffInt[2]     3.69   3.70    0.21      3.28      4.10
## detCoeffInt[3]     3.99   3.99    0.14      3.71      4.26
## detCoeffSlope[1]   0.26   0.26    0.09      0.08      0.43
## detCoeffSlope[2]  -0.13  -0.13    0.09     -0.32      0.05
## detCoeffSlope[3]   0.15   0.14    0.10     -0.06      0.34
## habCoeffInt        0.97   0.97    0.15      0.66      1.25
## habCoeffSlope      0.64   0.64    0.11      0.41      0.85
## sigma              0.09   0.09    0.00      0.08      0.09</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">round</span>(MCMC_samples2_summary, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##                    Mean Median St.Dev. 95%CI_low 95%CI_upp
## N                108.97 109.00    8.57     94.00    127.00
## detCoeffInt[1]    -2.01  -1.95    0.65     -3.42     -0.92
## detCoeffInt[2]    -0.93  -0.93    0.23     -1.38     -0.50
## detCoeffInt[3]    -0.82  -0.81    0.12     -1.07     -0.58
## detCoeffSlope[1]   0.41   0.41    0.06      0.29      0.53
## detCoeffSlope[2]  -0.07  -0.07    0.09     -0.25      0.10
## detCoeffSlope[3]   0.03   0.03    0.09     -0.15      0.22
## habCoeffSlope      0.57   0.57    0.12      0.33      0.79
## psi                0.36   0.36    0.04      0.29      0.45
## sigma              0.35   0.34    0.01      0.32      0.38</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">round</span>(MCMC_samples3_summary, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##                    Mean Median St.Dev. 95%CI_low 95%CI_upp
## N                138.91 138.00   12.72    116.00    166.00
## detCoeffInt[1]     3.43   3.44    0.84      1.69      5.04
## detCoeffInt[2]     3.68   3.69    0.21      3.24      4.09
## detCoeffInt[3]     3.98   3.98    0.14      3.70      4.26
## detCoeffSlope[1]   0.26   0.26    0.09      0.09      0.43
## detCoeffSlope[2]  -0.13  -0.13    0.09     -0.32      0.05
## detCoeffSlope[3]   0.14   0.14    0.10     -0.06      0.34
## habCoeffSlope      0.64   0.64    0.11      0.43      0.86
## psi                0.46   0.46    0.05      0.37      0.57
## sigma              0.09   0.09    0.00      0.08      0.09</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">round</span>(MCMC_samples4_summary, <span class="dv">2</span>)</a></code></pre></div>
<pre><code>##                   Mean Median St.Dev. 95%CI_low 95%CI_upp
## N                98.34  98.00    6.86     86.00    113.00
## detCoeffInt[1]    0.43   0.47    0.65     -0.99      1.55
## detCoeffInt[2]    1.33   1.34    0.21      0.93      1.73
## detCoeffInt[3]    1.47   1.48    0.12      1.24      1.70
## detCoeffSlope[1]  0.42   0.42    0.06      0.30      0.54
## detCoeffSlope[2]  0.01   0.02    0.09     -0.16      0.18
## detCoeffSlope[3]  0.00   0.00    0.09     -0.18      0.18
## habCoeffSlope    15.14  15.51    5.09      3.81     24.78
## psi               0.33   0.33    0.04      0.26      0.40
## sigma             0.33   0.33    0.01      0.31      0.36</code></pre>
<!--
And examine traceplots and posterior distributions for $N$ and $\sigma$:
-->
<p>Next, we can check the posterior effective sample size (ESS) resulting from our 40 000 posterior samples for the population size estimates (<span class="math inline">\(N\)</span>):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">round</span>(MCMC_samples1_ess,<span class="dv">2</span>)[<span class="kw">c</span>(<span class="st">&quot;N&quot;</span>,<span class="st">&quot;sigma&quot;</span>)] </a></code></pre></div>
<pre><code>##       N   sigma 
## 5646.59 1775.95</code></pre>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">round</span>(MCMC_samples2_ess,<span class="dv">2</span>)[<span class="kw">c</span>(<span class="st">&quot;N&quot;</span>,<span class="st">&quot;sigma&quot;</span>)] </a></code></pre></div>
<pre><code>##       N   sigma 
## 4472.89 2169.46</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">round</span>(MCMC_samples3_ess,<span class="dv">2</span>)[<span class="kw">c</span>(<span class="st">&quot;N&quot;</span>,<span class="st">&quot;sigma&quot;</span>)] </a></code></pre></div>
<pre><code>##       N   sigma 
## 2122.96 1552.12</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">round</span>(MCMC_samples4_ess,<span class="dv">2</span>)[<span class="kw">c</span>(<span class="st">&quot;N&quot;</span>,<span class="st">&quot;sigma&quot;</span>)] </a></code></pre></div>
<pre><code>##       N   sigma 
## 4476.06 2465.72</code></pre>
<p>We can also calculate the MCMC efficiency; this corresponds to the rate of generating effectively independent posterior samples, per second of MCMC runtime:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">round</span>(MCMC_samples1_ess,<span class="dv">2</span>)[<span class="st">&quot;N&quot;</span>]<span class="op">/</span><span class="kw">round</span>(MCMC_runtime1[<span class="dv">3</span>],<span class="dv">1</span>)</a></code></pre></div>
<pre><code>##         N 
## 0.2310625</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">round</span>(MCMC_samples2_ess,<span class="dv">2</span>)[<span class="st">&quot;N&quot;</span>]<span class="op">/</span><span class="kw">round</span>(MCMC_runtime2[<span class="dv">3</span>],<span class="dv">1</span>)</a></code></pre></div>
<pre><code>##         N 
## 0.9795007</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">round</span>(MCMC_samples3_ess,<span class="dv">2</span>)[<span class="st">&quot;N&quot;</span>]<span class="op">/</span><span class="kw">round</span>(MCMC_runtime3[<span class="dv">3</span>],<span class="dv">1</span>)</a></code></pre></div>
<pre><code>##         N 
## 0.5121119</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">round</span>(MCMC_samples4_ess,<span class="dv">2</span>)[<span class="st">&quot;N&quot;</span>]<span class="op">/</span><span class="kw">round</span>(MCMC_runtime4[<span class="dv">3</span>],<span class="dv">1</span>)</a></code></pre></div>
<pre><code>##         N 
## 0.2694068</code></pre>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>We can see that model 2 and 4 seem to overestimate individual space use (<span class="math inline">\(\sigma\)</span>), and underestimate <span class="math inline">\(N\)</span>, as a consequence of the coarse resolutions used for the habitat and detectors and the aggregation of activity centers and detections to the centers of the habitat and detector windows, respectively.</p>
<p>We can also see that the semi-likelihood approach is much slower than the data-augmentation for comparable models and results (Runtime : 6.8hrs for model 1 against 1.2hrs for model 3).</p>
<p>However, when looking at the efficiency, model 2 seems to perform better, thanks to the faster detection model using discrete locations (Efficiency : 0.9795007ESS/sec) (… but at the cost of poor population size estimates).</p>
<p>Overall, model 3, combining the detection point process and data augmentation seems to be the best compromise with accurate population size estimates and relatively good efficiency (Efficiency : 0.5121119ESS/sec)</p>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-nimbleSCR">
<p>Bischof, Richard, Daniel Turek, Cyril Milleret, Torbjørn Ergon, Pierre Dupont, and de Valpine Perry. 2020. <em>NimbleSCR: Spatial Capture-Recapture (Scr) Methods Using ’Nimble’</em>.</p>
</div>
<div id="ref-de2017programming">
<p>de Valpine, Perry, Daniel Turek, Christopher J Paciorek, Clifford Anderson-Bergman, Duncan Temple Lang, and Rastislav Bodik. 2017. “Programming with Models: Writing Statistical Algorithms for General Model Structures with NIMBLE.” <em>J. Comput. Graph. Stat.</em> 26 (2): 403–13.</p>
</div>
<div id="ref-King2016">
<p>King, R., B. T. McClintock, D. Kidney, and D. Borchers. 2016. “Capture–Recapture Abundance Estimation Using a Semi-Complete Data Likelihood Approach.” <em>The Annals of Applied Statistics</em> 10 (1): 264–85.</p>
</div>
<div id="ref-nimbleSoftware2020">
<p>NIMBLE Development Team. 2020. “NIMBLE: MCMC, Particle Filtering, and Programmable Hierarchical Modeling.” <a href="https://doi.org/10.5281/zenodo.1211190">https://doi.org/10.5281/zenodo.1211190</a>.</p>
</div>
<div id="ref-Royle2012">
<p>Royle, J Andrew, and Robert M Dorazio. 2012. “Parameter-Expanded Data Augmentation for Bayesian Analysis of Capture–Recapture Models.” <em>Journal of Ornithology</em> 152 (2): 521–37.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
